<!DOCTYPE html><html lang="de"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>tutorial - Software-Challenge Dokumentation</title><meta property="og:title" content="tutorial - Software-Challenge Dokumentation"/><meta name="description" content="Dokumentation der Software-Challenge Germany. Alle Informationen zu dem Ablauf, den technischen Grundlagen und Hilfestellungen."/><meta name="og:description" content="Dokumentation der Software-Challenge Germany. Alle Informationen zu dem Ablauf, den technischen Grundlagen und Hilfestellungen."/><meta name="next-head-count" content="6"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/3439ac9db3e6b67b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3439ac9db3e6b67b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-2f1f77e8550e6a72.js" defer=""></script><script src="/_next/static/chunks/framework-ce84985cd166733a.js" defer=""></script><script src="/_next/static/chunks/main-7828853baa8ec358.js" defer=""></script><script src="/_next/static/chunks/pages/_app-558775a13df2305b.js" defer=""></script><script src="/_next/static/chunks/175675d1-03f9945557e50186.js" defer=""></script><script src="/_next/static/chunks/57e613a8-9355bccbe9da6c24.js" defer=""></script><script src="/_next/static/chunks/7834-787c6e51cd4aaa43.js" defer=""></script><script src="/_next/static/chunks/9178-67efca4cdf656709.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...page%5D%5D-a036fac385acb5ca.js" defer=""></script><script src="/_next/static/gJRxG6W-71yU5ToWtMTf6/_buildManifest.js" defer=""></script><script src="/_next/static/gJRxG6W-71yU5ToWtMTf6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><style>:root {
            --color-brand: #3276AD;
            --color-brand-dark: #3276AD;
            --color-brand-text: white;
          }</style><style>
@font-face {
  font-family: hyperbook-body;
  src: url(/fonts/Inter-Regular.ttf);
}
</style><style>
@font-face {
  font-family: hyperbook-heading;
  src: url(/fonts/Inter-Regular.ttf);
}
</style><style>
@font-face {
  font-family: hyperbook-code;
  src: url(/fonts/SourceCodePro-Regular.ttf);
}
</style><style>
:root {
  --color-background: white;
  --color-text: black;
  --color-text-deactivated: #242428;
  --color-nav: #f5f5f5;
  --color-nav-border: #3c3c3c;
  --color-author-background: #d6d6d6;
  --color-author-color: #3c3c3c;
  --color-spacer: #a4a4a4;
}
        </style><style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-background: #1e1e1e;
    --color-text: #f5f5f5;
    --color-text-deactivated: #d6d6d6;
    --color-nav: #222222;
    --color-nav-border: #464646;
    --color-author-background: #2c2c2c;
    --color-author-color: #d6d6d6;
    --color-spacer: #3c3c3c;
    --color-brand: var(--color-brand-dark);
  }

  header {
    background: var(--color-nav);
  }

  .branding {
    color: var(--color-brand);
  }

  .toggle .bar1,
  .toggle .bar2,
  .toggle .bar3 {
    background-color: var(--color-brand);
  }
}</style><div class="main-grid"><header><div class="mobile-nav"><button aria-label="Nav Toggle" class="toggle"><div class="bar1"></div><div class="bar2"></div><div class="bar3"></div></button></div><a class="branding" href="/"><div class="logo"><img alt="Logo" src="/logo.svg"/></div><div class="name">Software-Challenge Dokumentation</div></a></header><div class="sidebar"><nav><ul><li><a class="page" href="/">Start</a></li><li><a class="page" href="/glossar">Technische Grundlagen</a></li><li><a class="page" href="/bookmark">Lesezeichen</a></li><li><a class="page" href="/faq">F.A.Q.</a></li></ul><div class="section"><div class="name "><a class="label" href="/allgemein">Die Software-Challenge</a><button class="toggle" id="react-collapsed-toggle-:Rpl6:" aria-controls="react-collapsed-panel-:Rpl6:" aria-expanded="true" type="button" role="button" tabindex="0" aria-label="Close">‚ûñ</button></div><div class="links" id="react-collapsed-panel-:Rpl6:" aria-hidden="false" role="region" style="box-sizing:border-box"><ul class="pages"><li><a class="page" href="/allgemein/wettkampf">Wettkampfmodalit√§ten</a></li><li><a class="page" href="/allgemein/spiel">Das Spiel kennenlernen</a></li></ul></div></div><div class="virtual-section"><div class="links"><div class="section"><div class="name "><a class="label" href="/spiele/mississippi-queen">Mississippi Queen</a><button class="toggle" id="react-collapsed-toggle-:R3b9l6:" aria-controls="react-collapsed-panel-:R3b9l6:" aria-expanded="true" type="button" role="button" tabindex="0" aria-label="Close">‚ûñ</button></div><div class="links" id="react-collapsed-panel-:R3b9l6:" aria-hidden="false" role="region" style="box-sizing:border-box"><ul class="pages"><li><a class="page" href="/spiele/mississippi-queen/regeln">Spielregeln</a></li></ul></div></div></div></div><div class="section"><div class="name "><a class="label" href="/entwicklung">Entwicklung</a><button class="toggle" id="react-collapsed-toggle-:R1pl6:" aria-controls="react-collapsed-panel-:R1pl6:" aria-expanded="false" type="button" role="button" tabindex="0" aria-label="Open">‚ûï</button></div><div class="links" id="react-collapsed-panel-:R1pl6:" aria-hidden="true" role="region" style="box-sizing:border-box;display:none;height:0px;overflow:hidden"><ul class="pages"><li><a class="page" href="/entwicklung/einfuehrung-oop">Objektorientierte Programmierung</a></li><li><a class="page" href="/entwicklung/sauberer-programmierstil">Sauberer Programmierstil</a></li><li><a class="page" href="/entwicklung/installation-von-java">Installation von Java</a></li><li><a class="page" href="/entwicklung/einrichtung-der-entwicklungsumgebung">Einrichtung der Entwicklungsumgebung</a></li><li><a class="page" href="/entwicklung/bedienung-von-eclipse">Bedienung von Eclipse</a></li><li><a class="page" href="/entwicklung/simpleclient-erweitern">Spielervorlage erweitern</a></li><li><a class="page" href="/entwicklung/eine-idee-implementieren">Idee implementieren</a></li><li><a class="page" href="/entwicklung/abgabe">Computerspieler abgabefertig machen</a></li></ul></div></div></nav><a class="author" href="https://hyperbook.openpatch.org">Powered by <b>Hyperbook</b></a></div><main><article><div class="hyperbook-markdown"><button class="toc-toggle" title="Table of Contents"><div class="bar1"></div><div class="bar2"></div><div class="bar3"></div><div class="bar4"></div></button><p><a href="/tutorial.pdf">PDF-Version dieses Dokumentes</a></p>
<h1><a class="heading" id="start-zum-schreiben-einer-ki" href="#start-zum-schreiben-einer-ki"><span>Start zum Schreiben einer KI</span></a><button class="bookmark" title="Bookmark">üîñ</button></h1>
<p>Am einfachsten ist es die KI auf Grundlage des Zufallsspielers zu
schreiben:</p>
<ul>
<li>
<p>Als erstes muss der Zufallsspieler heruntergeladen werden
(<a href="http://www.software-challenge.de/downloads/">http://www.software-challenge.de/downloads/</a> bitte den
Zufallsspieler als ‚ÄûQuellcode‚Äú downloaden)</p>
</li>
<li>
<p>Dieser muss nun in Eclips eingebunden werden:
<a href="https://docs.software-challenge.de/#einrichtung-von-eclipse">https://docs.software-challenge.de/#einrichtung-von-eclipse</a></p>
</li>
</ul>
<h2><a class="heading" id="wo-schreibe-ich-die-ki" href="#wo-schreibe-ich-die-ki"><span>Wo schreibe ich die KI?</span></a><button class="bookmark" title="Bookmark">üîñ</button></h2>
<p>Ist dies getan befindet sich im entsprechenden Projekt das Package
‚Äûsc.player2018.logic‚Äú mit einer Datei namens <strong>‚ÄûRandomLogic.java‚Äú</strong>.
Diese Datei m√ºssen wir nun editieren.</p>
<p>In der Datei gibt es eine Funktion mit der Bezeichnung <em>public void
onRequestAction()</em>. Diese ist wie Folgt aufgebaut:</p>
<pre><code class="hljs language-scss">public void <span class="hljs-built_in">onRequestAction</span>(){
  <span class="hljs-comment">// optional: Laufzeitmessung</span>
  long startTime = System<span class="hljs-selector-class">.nanoTime</span>();


  <span class="hljs-comment">// Quellcode der KI, welche eine Zug (move) erstellt</span>


  long nowTime = System<span class="hljs-selector-class">.nanoTime</span>();

  <span class="hljs-comment">// sende Move. Danach gibt es kein zur√ºck mehr:</span>
  <span class="hljs-built_in">sendAction</span>(move);

  <span class="hljs-comment">// optional: LOG-Eintrag mit Zeit:</span>
  log<span class="hljs-selector-class">.warn</span>(&quot;Time needed for turn: {}&quot;, (nowTime - startTime) / <span class="hljs-number">1000000</span>);
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Es ist sehr wichtig, dass alle Funktionen, welche die KI verwendet,
ihren urspr√ºnglichen Aufruf in der Funktion onRequestAction haben.
Dadurch wird sichergestellt, dass alle Membervariablen aktuell sind.</p>
<h2><a class="heading" id="wichtige-membervariablen" href="#wichtige-membervariablen"><span>Wichtige Membervariablen</span></a><button class="bookmark" title="Bookmark">üîñ</button></h2>
<p>In der Klasse befinden sich auch drei sehr wichtige Membervariablen:</p>
<pre><code class="hljs language-arduino"><span class="hljs-keyword">private</span> Starter client; <span class="hljs-comment">// Intern f√ºr den Server wichtig. Bitte nicht modifizieren</span>

<span class="hljs-keyword">private</span> GameState gameState; <span class="hljs-comment">// Gibt u.a Infos √ºber m√∂gliche Z√ºge und das Spielbrett</span>

<span class="hljs-keyword">private</span> Player currentPlayer; <span class="hljs-comment">// Infos √ºber den aktuellen Spieler, welchen man steuert</span>
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>In den Folgenden Dokumenten werden Grundlagen zum erstellen einer KI
gezeigt. Hierbei werden wir oft die Variablen <strong>gameState</strong> und
<strong>currentPlayer</strong> verwenden.</p>
<p>Die <strong>API-Dokumentation</strong> befindet sich im Ordner ‚Äûdoc‚Äú im Verzeichnis
des Zufallsspielers.</p>
<h2><a class="heading" id="aufgaben" href="#aufgaben"><span>Aufgaben</span></a><button class="bookmark" title="Bookmark">üîñ</button></h2>
<ol>
<li>
<p>Arbeite alle anderen Dokumente durch.</p>
</li>
<li>
<p>Analysiere die Herangehensweise der Zufallsspieler-KI.</p>
</li>
<li>
<p>Schreibe eine KI.</p>
</li>
</ol>
<h1><a class="heading" id="spielbrett-informationen" href="#spielbrett-informationen"><span>Spielbrett Informationen</span></a><button class="bookmark" title="Bookmark">üîñ</button></h1>
<h2><a class="heading" id="die-klasse-fieldtype" href="#die-klasse-fieldtype"><span>Die Klasse ‚ÄûFieldType‚Äú</span></a><button class="bookmark" title="Bookmark">üîñ</button></h2>
<p>Bevor wir mit der Klasse Board also dem Spielbrett arbeiten k√∂nnen,
m√ºssen wir das Enum ‚ÄûFieldType‚Äú kennenlernen. Dieses Enum definiert die
einzelnen Felder des Bretts. Es gibt:</p>
<p>Die Dokumentation f√ºr FieldType ist in /doc/sc/plugin2018/FieldType.html
zu finden.</p>
<h2><a class="heading" id="funktionen-der-klasse-board" href="#funktionen-der-klasse-board"><span>Funktionen der Klasse ‚ÄûBoard‚Äú</span></a><button class="bookmark" title="Bookmark">üîñ</button></h2>
<p>Das Spielbrett kann man sich wie einer Art modifizieren ‚ÄûArray‚Äú [1]
vorstellen. Mithilfe der FieldTypes k√∂nnen wir die Funktionen des Boards
verwenden. Zun√§chst stellt sich allerdings die Frage, wie wir √ºberhaupt
das Spielbrett bekommen k√∂nnen. Das Spielbrett bekommen wir durch den
GameState. Mit Hilfe der Methode <em>gameState.getBoard()</em>.</p>
<p>Unsere Eigene Position k√∂nnen wir mithilfe von <strong>currentPlayer</strong> oder
<strong>gameState</strong> herausfinden:</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// Es wird immer ein Integer zwischen 0 bis 64 zur√ºckgegeben:</span>
currentPlayer<span class="hljs-selector-class">.getFieldIndex</span>();
<span class="hljs-comment">// dasselbe wie oben:</span>
gameState<span class="hljs-selector-class">.getCurrentPlayer</span>()<span class="hljs-selector-class">.getFieldIndex</span>();

if (currentPlayer.getFieldIndex() == gameState<span class="hljs-selector-class">.getCurrentPlayer</span>()<span class="hljs-selector-class">.getFieldIndex</span>()) {
  <span class="hljs-comment">//wird immer ausgef√ºhrt</span>
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<h3><a class="heading" id="public-final-int-getnextfieldbytypefieldtype-typeint-pos" href="#public-final-int-getnextfieldbytypefieldtype-typeint-pos"><span>public final int getNextFieldByType(FieldType type,int pos)</span></a><button class="bookmark" title="Bookmark">üîñ</button></h3>
<p>Dieser Funktion √ºbergeben wir eine Position und ein FieldType. Es gibt
die Position des n√§chsten FieldType an, welches <strong>nach</strong> der angegeben
Position liegt. Hat das Feld mit der angegeben Position, den gleichen
FieldType, so wird dennoch die Position des n√§chsten Felds angegeben
(siehe zweites Beispiel). Gibt es diesen FieldType nicht mehr wird -1
zur√ºckgegeben.</p>
<pre><code class="hljs language-scss">gameState<span class="hljs-selector-class">.getBoard</span>()<span class="hljs-selector-class">.getNextFieldByType</span>(FieldType.GOAL,
                                        currentPlayer.getFieldIndex());
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Dies w√ºrde in einem normalen Spiel immer 64 zur√ºckgeben, au√üer man
befindet sich auf dem Ziel. Im diesem Fall w√§re das Ergebnis -1.</p>
<pre><code class="hljs language-ini">// Damit man nicht immer gameState.getBoard() schreiben muss:
Board <span class="hljs-attr">b</span> = gameState.getBoard()<span class="hljs-comment">;</span>
final int <span class="hljs-attr">index</span> = currentPlayer.getFieldIndex()<span class="hljs-comment">; // Index des Spielers</span>

if (<span class="hljs-attr">index</span> == b.getNextFieldByType(b.getTypeAt(index), index)) {
  System.out.println(&quot;Geht nicht&quot;)<span class="hljs-comment">;</span>
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Dies liegt daran, dass der verwendete Index nie der R√ºckgabewert von
<strong>getNextFieldByType</strong> sein kann.</p>
<pre><code class="hljs language-ini">int <span class="hljs-attr">next_hedgehog</span> = b.getNextFieldByType(FieldType.HEDGEHOG,
                                         currentPlayer.getFieldIndex())<span class="hljs-comment">;</span>
int <span class="hljs-attr">next_next_hedgehog</span> = b.getNextFieldByType(FieldType.HEDGEHOG, next_hedgehog)<span class="hljs-comment">;</span>
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Dies w√ºrde die Postion des n√§chste und vom √ºbern√§chste Igelfeld
bestimmen. Achtung es wird hierbei nicht √ºberpr√ºft, ob es so ein Feld
√ºberhaupt gibt. Dies kann zu Fehlern f√ºhren. Steht man z.B auf dem
letzten Igelfeld, so hat <strong>next_next_hedgehog</strong> den Wert 11, anstelle
von -1 (Siehe √úbung 2).</p>
<h3><a class="heading" id="public-final-int-getpreviousfieldbytypefieldtype-typeint-pos" href="#public-final-int-getpreviousfieldbytypefieldtype-typeint-pos"><span>public final int getPreviousFieldByType(FieldType type,int pos)</span></a><button class="bookmark" title="Bookmark">üîñ</button></h3>
<p>Analog zu getNextFieldByType. Allerdings bezieht sich die Funktion auf
das vorherige Feld mit dem entsprechenden FieldType.</p>
<h3><a class="heading" id="public-final-fieldtype-gettypeatint-pos" href="#public-final-fieldtype-gettypeatint-pos"><span>public final FieldType getTypeAt(int pos)</span></a><button class="bookmark" title="Bookmark">üîñ</button></h3>
<p>Mit dieser Funktionen kann man den FieldType eines bestimmten Feldes
ermitteln.</p>
<pre><code class="hljs language-ini">FieldType <span class="hljs-attr">my_field</span> = gameState.getBoard().getTypeAt(currentPlayer.getFieldIndex())<span class="hljs-comment">;</span>
FieldType <span class="hljs-attr">field_42</span> = gameState.getBoard().getTypeAt(<span class="hljs-number">42</span>)<span class="hljs-comment">;</span>
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Speichert den aktuelle FieldType auf welchen man steht und den FieldType
des Feldes 42.</p>
<pre><code class="hljs language-less"><span class="hljs-selector-tag">if</span> (gameState.<span class="hljs-built_in">getBoard</span>().<span class="hljs-built_in">getTypeAt</span>(-<span class="hljs-number">1</span>) == FieldType.INVALID) {
  <span class="hljs-comment">// Wird immer ausgef√ºhrt, da es das Feld an der Position -1 nicht gibt</span>
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Dieses Beispiel zeigt auf, dass es durch getTypeAt nie zu einer
IndexOutOfBoundsException kommen kann. Es gibt nur Felder im Intervall
von 0 ‚Äì 64. Sollte man nach einem Feld au√üerhalb diese Intervalls
fragen, so wird immer INVALID zur√ºckgegeben.</p>
<p>Die komplette API-Dokumentation ist in /doc/sc/plugin2018/Board.html zu
finden.</p>
<h2><a class="heading" id="aufgaben" href="#aufgaben"><span>Aufgaben</span></a><button class="bookmark" title="Bookmark">üîñ</button></h2>
<ol>
<li>
<p>Gib die Entfernung des Gegners zum Startfeld aus. Verwende dabei
keine Variablen oder Literale. Die Ausnahme ist der R√ºckgabewert.
Dieser darf eine Literale sein (z.B. return 127;). Tipp: Suche in
der API von GameState nach einer Funktion, welchen den anderen
Spieler zur√ºckgibt oder lese das Dokument ‚ÄûHase_Igel_Player‚Äú.</p>
</li>
<li>
<p>Erkl√§re warum <strong>next_next_hedgehog</strong> den Wert 11 h√§tte, wenn wir
auf den letzten Igelfeld stehen w√ºrden.</p>
<pre><code class="hljs language-ini">int <span class="hljs-attr">next_hedgehog</span> = b.getNextFieldByType(FieldType.HEDGEHOG,
                                         currentPlayer.getFieldIndex())<span class="hljs-comment">;</span>
int <span class="hljs-attr">next_next_hedgehog</span> = b.getNextFieldByType(FieldType.HEDGEHOG, next_hedgehog)<span class="hljs-comment">;</span>
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
</li>
<li>
<p>Schreibe eine Funktion, welche das √ºbern√§chste Igelfeld ausgibt.
Gibt es solch ein Feld nicht, so soll immer -1 zur√ºckgegeben werden.</p>
</li>
</ol>
<h1><a class="heading" id="die-klasse-player" href="#die-klasse-player"><span>Die Klasse Player</span></a><button class="bookmark" title="Bookmark">üîñ</button></h1>
<p>Die Klasse Player repr√§sentiert einen Spieler. Der eigene Spieler kann
in der RandomLogic durch die Variable <strong>currentPlayer</strong> oder mithilfe
der GameState Funktion <em>getCurrentPlayer()</em> abgefragt werden. Der
gegnerische Spieler kann ebenfalls mithilfe einer Methode von GameState
bestimmt werden (<em>gameState.getOtherPlayer()</em>).</p>
<p>Die Klasse Player besitzt viele Funktionen, welche einen Informationen
√ºber den Spieler geben:</p>
<p>Die Vollst√§ndige API ist in /doc/sc/plugin2018/Player.html zu finden.</p>
<p>Die Meisten dieser Funktionen sind selbsterkl√§rend. Dennoch sind hier
einige Beispiele angegeben:</p>
<pre><code class="hljs language-csharp">System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;Du hast noch folgende Karten: &quot;</span>);
<span class="hljs-keyword">for</span> (CardType c : currentPlayer.getCards()) {
    System.<span class="hljs-keyword">out</span>.print(c + <span class="hljs-string">&quot; &quot;</span>);
}
System.<span class="hljs-keyword">out</span>.println();
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Dies w√ºrde alle Karten ausgeben, welche man noch hat.</p>
<pre><code class="hljs language-less"><span class="hljs-selector-tag">if</span> (currentPlayer.<span class="hljs-built_in">inGoal</span>() &amp;&amp; !currentPlayer.<span class="hljs-built_in">getCards</span>().<span class="hljs-built_in">isEmpty</span>()) {
    <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;Was fuer eine Verschwendung.&quot;</span>);
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Die If-Bedingung w√ºrde dann ausgef√ºhrt werden, wenn man im Ziel ist,
allerdings noch Karten hat.</p>
<p>Eine weitere wichtige Funktion ist <em>getFieldIndex</em>. Diese Funktion wird
h√§ufig im Dokument ‚ÄûHase_Igel_Spielbrett‚Äú verwendet.</p>
<p>Neben diesen Funktionen existieren noch einige ‚ÄûSetter‚Äú. Diese sind
allerdings haupts√§chlich f√ºr den Server notwendig und haben einen
geringen praktischen Nutzten f√ºr uns.</p>
<h2><a class="heading" id="aufgabe" href="#aufgabe"><span>Aufgabe</span></a><button class="bookmark" title="Bookmark">üîñ</button></h2>
<p>Schreibe eine If-Bedingung, welche abfragt, ob beide Spieler auf dem
selben Feld sind. Da dies nur m√∂glich ist, wenn man auf dem Start-
Zielfeld ist, soll zun√§chst abgefragt werden, ob der aktuelle Spieler
auf dem Start- Zielfeld ist. Tipp: Es gibt die Funktion getTypeAt der
Klasse Board. Weiter Informationen sind im Dokument
‚ÄûHase_Igel_Spielbrett‚Äú zu finden.</p>
<h1><a class="heading" id="gamerulelogic-hilfreiche-hilfsfunktionen" href="#gamerulelogic-hilfreiche-hilfsfunktionen"><span>GameRuleLogic: Hilfreiche Hilfsfunktionen</span></a><button class="bookmark" title="Bookmark">üîñ</button></h1>
<p>Die Klasse GameRuleLogic hat viele Hilfsfunktionen, mit welchen man die
Regeln des Spieles √ºberpr√ºfen kann. Hierbei sind alle Funktionen static.
D.h., dass man sie ohne eine Instanz aufrufen kann.</p>
<p>*Diese Funktionen werden im Kapitel ‚ÄûErweiterte Beispiele‚Äú besprochen.</p>
<p>Die komplette API-Dokumentation ist in
doc/sc/plugin2018/util/GameRuleLogic.html zu finden.</p>
<h2><a class="heading" id="simulation-des-gegners" href="#simulation-des-gegners"><span>Simulation des Gegners</span></a><button class="bookmark" title="Bookmark">üîñ</button></h2>
<p>Nat√ºrlich kann man alle diese Funktionen auch auf den Gegenspieler
anwenden. Daf√ºr m√ºssen wir allerdings eine Kopie des GameState
erstellen:</p>
<pre><code class="hljs language-scss">try {
  GameState otherGame = gameState<span class="hljs-selector-class">.clone</span>(); <span class="hljs-comment">// Deep-Copy</span>
  <span class="hljs-comment">// Rundenanzahl hochsetzten f√ºr switch Befehl:</span>
  otherGame<span class="hljs-selector-class">.setTurn</span>(gameState.getTurn()+<span class="hljs-number">1</span>);
  <span class="hljs-comment">// Tausche currentPlayer (h√§ngt von der Rundenanzahl ab):</span>
  otherGame<span class="hljs-selector-class">.switchCurrentPlayer</span>();
  <span class="hljs-comment">// Gib Informationen √ºber den Gegner aus:</span>
  System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(&quot;CurrentPlayer von otherGame:&quot; + otherGame.getCurrentPlayer());
} catch (CloneNotSupportedException e1) { <span class="hljs-comment">// Fehlerbehandlung</span>
  e1<span class="hljs-selector-class">.printStackTrace</span>();
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Alle Funktionen von GameRuleLogic k√∂nnen wir nun, mithilfe der Variable
otherGame, auf den Gegner anwenden.</p>
<h2><a class="heading" id="einfhrende-beispiele" href="#einfhrende-beispiele"><span>Einf√ºhrende Beispiele</span></a><button class="bookmark" title="Bookmark">üîñ</button></h2>
<p>Die meisten Funktionen dieser Klasse sind selbsterkl√§rend. Dennoch
werden einige der h√§ufig verwendeten Funktionen mit kleinen Beispielen
vorgestellt.</p>
<pre><code class="hljs language-less"><span class="hljs-selector-tag">if</span> (GameRuleLogic.<span class="hljs-built_in">isValidToEat</span>(gameState) != GameRuleLogic.<span class="hljs-built_in">mustEatSalad</span>(gameState)) {
  <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;Unm√∂glich&quot;</span>);
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Nach den Regeln muss man immer ein Salat essen, wenn man im vorherigen
Zug ein Salatfeld betreten hat. Au√üerdem ist dies die einzige
M√∂glichkeit die Aktion EatSalad auszuf√ºhren (nicht mit dem Spielen der
EAT_SALAD Karte verwechseln).</p>
<p>Dadurch wird auch die Unerf√ºllbarkeit des folgenden Ausdrucks
impliziert:</p>
<pre><code class="hljs language-less"><span class="hljs-selector-tag">if</span> (GameRuleLogic.<span class="hljs-built_in">isValidToEat</span>(gameState) &amp;&amp;
    (GameRuleLogic.<span class="hljs-built_in">isValidToFallBack</span>(gameState) || GameRuleLogic.<span class="hljs-built_in">canMove</span>(gameState))) {
  <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;Unm√∂glich&quot;</span>);
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Eine weiter hilfreiche Funktion ist <em>isValidToAdvance</em>. Mit dieser
Funktion wird √ºberpr√ºft, ob ein Vorw√§rtszug mit der √ºbergeben Distanz
√ºberhaupt m√∂glich ist:</p>
<pre><code class="hljs language-csharp"><span class="hljs-comment">// berechne die maximale Entfernung, welche man laufen darf</span>
<span class="hljs-built_in">int</span> max_move = GameRuleLogic.calculateMoveableFields(currentPlayer.getCarrots());

<span class="hljs-keyword">if</span> (GameRuleLogic.isValidToAdvance(gameState, max_move +<span class="hljs-number">1</span>)) {
  System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Unm√∂glich&quot;</span>);
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Die Funktion <em>calculateMoveableFields</em> gibt hierbei die maximale
Entfernung zur√ºck, welche man mit den √ºbergebenen Karotten laufen darf.
Diese maximale Entfernung wird immer um 1 erh√∂ht, was dazu f√ºhrt, dass
der Zug immer unm√∂glich ist.</p>
<h2><a class="heading" id="erweitertes-beispiel" href="#erweitertes-beispiel"><span>Erweitertes Beispiel</span></a><button class="bookmark" title="Bookmark">üîñ</button></h2>
<p>Alle Funktionen die mit einem * markiert wurden (s.o) haben eine
Gemeinsamkeit. Sie beziehen sich auf das Spielen von Karten. Das Spielen
von Karten ist allerdings nur erlaubt, wenn man das entsprechende
Hasenfeld in der selben Zug betreten hat. Deshalb m√ºssen wir GameState
bearbeiten, damit diese Funktionen √ºberhaupt Sinn haben. Das folgende
Beispiel gibt eine M√∂glichkeit an, wie man diese Funktionen einsetzten
kann:</p>
<pre><code class="hljs language-scss">int nextHareFieldIndex = gameState<span class="hljs-selector-class">.getNextFieldByType</span>(FieldType.HARE,
                                                      currentPlayer.getFieldIndex())
<span class="hljs-comment">// wenn es ein n√§chstes Hasenfeld gibt</span>
if (nextHareFieldIndex &gt; <span class="hljs-number">0</span>) {
  try {

    GameState gameHare = gameState<span class="hljs-selector-class">.clone</span>(); <span class="hljs-comment">// erstelle Deep-Copy</span>
    Player harePlayer = gameHare<span class="hljs-selector-class">.getCurrentPlayer</span>(); <span class="hljs-comment">// erstelle Shallow-Copy</span>

    <span class="hljs-comment">//setzte den aktuellen Spieler auf ein Hasenfeld</span>
    harePlayer<span class="hljs-selector-class">.setFieldIndex</span>(nextHareFieldIndex);
    System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(gameHare.getCurrentPlayer()<span class="hljs-selector-class">.getCards</span>()); <span class="hljs-comment">// gib alle Karten aus</span>

    <span class="hljs-comment">// Welche Karten kann man spielen?</span>
    System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(&quot;Play EatSalad: &quot; +
                       GameRuleLogic.isValidToPlayEatSalad(gameHare));
    System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(&quot;Play TakeOrDropCarrots: &quot; +
                       GameRuleLogic.isValidToPlayTakeOrDropCarrots(gameHare,<span class="hljs-number">20</span>));
    System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(&quot;Play HurryAhead: &quot; +
                       GameRuleLogic.isValidToPlayHurryAhead(gameHare));
    System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(&quot;Play FallBack: &quot; +
                       GameRuleLogic.isValidToPlayFallBack(gameHare));

  } catch (CloneNotSupportedException e1) {
    e1<span class="hljs-selector-class">.printStackTrace</span>();
  }
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Hierf√ºr m√ºssen wir den Spieler einfach nur auf das Hasenfeld setzten.
Allerdings wird nicht √ºberpr√ºft, ob der Spieler √ºberhaupt bis zum
n√§chsten Hasenfeld laufen kann.</p>
<h2><a class="heading" id="aufgaben" href="#aufgaben"><span>Aufgaben</span></a><button class="bookmark" title="Bookmark">üîñ</button></h2>
<ol>
<li>Ist das Ausf√ºhren der inneren If-Bedingung wirklich unm√∂glich.
Erkl√§re warum oder gib ein Gegenbeispiel an:</li>
</ol>
<pre><code class="hljs language-scss">int dif = gameState<span class="hljs-selector-class">.getOtherPlayer</span>()<span class="hljs-selector-class">.getFieldIndex</span>() - currentPlayer<span class="hljs-selector-class">.getFieldIndex</span>();

if (dif &gt;= <span class="hljs-number">0</span> &amp;&amp;
    dif &lt;= GameRuleLogic.calculateMoveableFields(currentPlayer.getCarrots())) {
  if (GameRuleLogic.isValidToAdvance(gameState, dif)) {
    System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(&quot;Unm√∂glich&quot;);
  }
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<ol>
<li>Erweiterte das Beispiel aus dem Kapitel ‚ÄûErweitertes Beispiel‚Äú so,
dass sicher gestellt wird, dass der aktuelle Spieler auf ein
Hasenfeld gesetzt wird, welches er wirklich erreichen kann.</li>
</ol>
<p>[1] Technisch gesehen hat die Klasse eine private Liste von Feldern.
Allerdings √§hnelt ein Aufruf der Funktion getTypeAt sehr den Aufruf
eines Arrays. Auch wenn der R√ºckgabewert kein Feld sonder ein FieldType
ist.</p></div></article><div class="jump-container"><a class="jump previous" href="/spiele/hase-und-igel/tutorial/start">start</a><a class="jump next" href="/spiele/hase-und-igel/xml-dokumentation/einleitung-xml">einleitung-xml</a></div><div class="meta"><a class="edit-github" href="https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/tutorial.md">‚úé GitHub</a><span class="copyright"><a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0">Licensed under <!-- -->CC BY-NC-SA</a> by <a href="https://software-challenge.de">Software-Challenge Germany</a>.</span></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"locale":"de","markdown":"[PDF-Version dieses Dokumentes](tutorial.pdf)\n\n# Start zum Schreiben einer KI\n\nAm einfachsten ist es die KI auf Grundlage des Zufallsspielers zu\nschreiben:\n\n-   Als erstes muss der Zufallsspieler heruntergeladen werden\n    (\u003chttp://www.software-challenge.de/downloads/\u003e bitte den\n    Zufallsspieler als ‚ÄûQuellcode‚Äú downloaden)\n\n-   Dieser muss nun in Eclips eingebunden werden:\n    \u003chttps://docs.software-challenge.de/#einrichtung-von-eclipse\u003e\n\n## Wo schreibe ich die KI?\n\nIst dies getan befindet sich im entsprechenden Projekt das Package\n‚Äûsc.player2018.logic‚Äú mit einer Datei namens **‚ÄûRandomLogic.java‚Äú**.\nDiese Datei m√ºssen wir nun editieren.\n\nIn der Datei gibt es eine Funktion mit der Bezeichnung *public void\nonRequestAction()*. Diese ist wie Folgt aufgebaut:\n\n    public void onRequestAction(){\n      // optional: Laufzeitmessung\n      long startTime = System.nanoTime();\n\n\n      // Quellcode der KI, welche eine Zug (move) erstellt\n\n\n      long nowTime = System.nanoTime();\n\n      // sende Move. Danach gibt es kein zur√ºck mehr:\n      sendAction(move);\n\n      // optional: LOG-Eintrag mit Zeit:\n      log.warn(\"Time needed for turn: {}\", (nowTime - startTime) / 1000000);\n    }\n\nEs ist sehr wichtig, dass alle Funktionen, welche die KI verwendet,\nihren urspr√ºnglichen Aufruf in der Funktion onRequestAction haben.\nDadurch wird sichergestellt, dass alle Membervariablen aktuell sind.\n\n## Wichtige Membervariablen\n\nIn der Klasse befinden sich auch drei sehr wichtige Membervariablen:\n\n    private Starter client; // Intern f√ºr den Server wichtig. Bitte nicht modifizieren\n\n    private GameState gameState; // Gibt u.a Infos √ºber m√∂gliche Z√ºge und das Spielbrett\n\n    private Player currentPlayer; // Infos √ºber den aktuellen Spieler, welchen man steuert\n\nIn den Folgenden Dokumenten werden Grundlagen zum erstellen einer KI\ngezeigt. Hierbei werden wir oft die Variablen **gameState** und\n**currentPlayer** verwenden.\n\nDie **API-Dokumentation** befindet sich im Ordner ‚Äûdoc‚Äú im Verzeichnis\ndes Zufallsspielers.\n\n## Aufgaben\n\n1.  Arbeite alle anderen Dokumente durch.\n\n2.  Analysiere die Herangehensweise der Zufallsspieler-KI.\n\n3.  Schreibe eine KI.\n\n# Spielbrett Informationen\n\n## Die Klasse ‚ÄûFieldType‚Äú\n\nBevor wir mit der Klasse Board also dem Spielbrett arbeiten k√∂nnen,\nm√ºssen wir das Enum ‚ÄûFieldType‚Äú kennenlernen. Dieses Enum definiert die\neinzelnen Felder des Bretts. Es gibt:\n\n\u003ctable\u003e\n\u003ccolgroup\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003c/colgroup\u003e\n\u003ctbody\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eCARROT\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eKarottenfeld\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eGOAL\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eZielfeld\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eHARE\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eHasenfeld\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eHEDGEHOG\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eIgelfeld\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eSALAD\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eSalatfeld\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eSTART\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eStart\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003ePOSITION_1\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003ePositionsfelder\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003ePOSITION_2\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eINVALID\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eUng√ºltig\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\nDie Dokumentation f√ºr FieldType ist in /doc/sc/plugin2018/FieldType.html\nzu finden.\n\n## Funktionen der Klasse ‚ÄûBoard‚Äú\n\nDas Spielbrett kann man sich wie einer Art modifizieren ‚ÄûArray‚Äú [1]\nvorstellen. Mithilfe der FieldTypes k√∂nnen wir die Funktionen des Boards\nverwenden. Zun√§chst stellt sich allerdings die Frage, wie wir √ºberhaupt\ndas Spielbrett bekommen k√∂nnen. Das Spielbrett bekommen wir durch den\nGameState. Mit Hilfe der Methode *gameState.getBoard()*.\n\nUnsere Eigene Position k√∂nnen wir mithilfe von **currentPlayer** oder\n**gameState** herausfinden:\n\n    // Es wird immer ein Integer zwischen 0 bis 64 zur√ºckgegeben:\n    currentPlayer.getFieldIndex();\n    // dasselbe wie oben:\n    gameState.getCurrentPlayer().getFieldIndex();\n\n    if (currentPlayer.getFieldIndex() == gameState.getCurrentPlayer().getFieldIndex()) {\n      //wird immer ausgef√ºhrt\n    }\n\n### public final int getNextFieldByType(FieldType type,int pos)\n\nDieser Funktion √ºbergeben wir eine Position und ein FieldType. Es gibt\ndie Position des n√§chsten FieldType an, welches **nach** der angegeben\nPosition liegt. Hat das Feld mit der angegeben Position, den gleichen\nFieldType, so wird dennoch die Position des n√§chsten Felds angegeben\n(siehe zweites Beispiel). Gibt es diesen FieldType nicht mehr wird -1\nzur√ºckgegeben.\n\n    gameState.getBoard().getNextFieldByType(FieldType.GOAL,\n                                            currentPlayer.getFieldIndex());\n\nDies w√ºrde in einem normalen Spiel immer 64 zur√ºckgeben, au√üer man\nbefindet sich auf dem Ziel. Im diesem Fall w√§re das Ergebnis -1.\n\n    // Damit man nicht immer gameState.getBoard() schreiben muss:\n    Board b = gameState.getBoard();\n    final int index = currentPlayer.getFieldIndex(); // Index des Spielers\n\n    if (index == b.getNextFieldByType(b.getTypeAt(index), index)) {\n      System.out.println(\"Geht nicht\");\n    }\n\nDies liegt daran, dass der verwendete Index nie der R√ºckgabewert von\n**getNextFieldByType** sein kann.\n\n    int next_hedgehog = b.getNextFieldByType(FieldType.HEDGEHOG,\n                                             currentPlayer.getFieldIndex());\n    int next_next_hedgehog = b.getNextFieldByType(FieldType.HEDGEHOG, next_hedgehog);\n\nDies w√ºrde die Postion des n√§chste und vom √ºbern√§chste Igelfeld\nbestimmen. Achtung es wird hierbei nicht √ºberpr√ºft, ob es so ein Feld\n√ºberhaupt gibt. Dies kann zu Fehlern f√ºhren. Steht man z.B auf dem\nletzten Igelfeld, so hat **next\\_next\\_hedgehog** den Wert 11, anstelle\nvon -1 (Siehe √úbung 2).\n\n### public final int getPreviousFieldByType(FieldType type,int pos)\n\nAnalog zu getNextFieldByType. Allerdings bezieht sich die Funktion auf\ndas vorherige Feld mit dem entsprechenden FieldType.\n\n### public final FieldType getTypeAt(int pos)\n\nMit dieser Funktionen kann man den FieldType eines bestimmten Feldes\nermitteln.\n\n    FieldType my_field = gameState.getBoard().getTypeAt(currentPlayer.getFieldIndex());\n    FieldType field_42 = gameState.getBoard().getTypeAt(42);\n\nSpeichert den aktuelle FieldType auf welchen man steht und den FieldType\ndes Feldes 42.\n\n    if (gameState.getBoard().getTypeAt(-1) == FieldType.INVALID) {\n      // Wird immer ausgef√ºhrt, da es das Feld an der Position -1 nicht gibt\n    }\n\nDieses Beispiel zeigt auf, dass es durch getTypeAt nie zu einer\nIndexOutOfBoundsException kommen kann. Es gibt nur Felder im Intervall\nvon 0 ‚Äì 64. Sollte man nach einem Feld au√üerhalb diese Intervalls\nfragen, so wird immer INVALID zur√ºckgegeben.\n\nDie komplette API-Dokumentation ist in /doc/sc/plugin2018/Board.html zu\nfinden.\n\n## Aufgaben\n\n1.  Gib die Entfernung des Gegners zum Startfeld aus. Verwende dabei\n    keine Variablen oder Literale. Die Ausnahme ist der R√ºckgabewert.\n    Dieser darf eine Literale sein (z.B. return 127;). Tipp: Suche in\n    der API von GameState nach einer Funktion, welchen den anderen\n    Spieler zur√ºckgibt oder lese das Dokument ‚ÄûHase\\_Igel\\_Player‚Äú.\n\n2.  Erkl√§re warum **next\\_next\\_hedgehog** den Wert 11 h√§tte, wenn wir\n    auf den letzten Igelfeld stehen w√ºrden.\n\n        int next_hedgehog = b.getNextFieldByType(FieldType.HEDGEHOG,\n                                                 currentPlayer.getFieldIndex());\n        int next_next_hedgehog = b.getNextFieldByType(FieldType.HEDGEHOG, next_hedgehog);\n\n3.  Schreibe eine Funktion, welche das √ºbern√§chste Igelfeld ausgibt.\n    Gibt es solch ein Feld nicht, so soll immer -1 zur√ºckgegeben werden.\n\n# Die Klasse Player\n\nDie Klasse Player repr√§sentiert einen Spieler. Der eigene Spieler kann\nin der RandomLogic durch die Variable **currentPlayer** oder mithilfe\nder GameState Funktion *getCurrentPlayer()* abgefragt werden. Der\ngegnerische Spieler kann ebenfalls mithilfe einer Methode von GameState\nbestimmt werden (*gameState.getOtherPlayer()*).\n\nDie Klasse Player besitzt viele Funktionen, welche einen Informationen\n√ºber den Spieler geben:\n\n\u003ctable\u003e\n\u003ccolgroup\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003c/colgroup\u003e\n\u003ctbody\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003ejava.util.List\u0026lt;CardType\u0026gt;\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetCards()\u003c/em\u003e\u003cbr /\u003e\nGibt die f√ºr diesen Spieler verf√ºgbaren Hasenkarten zur√ºck.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003ejava.util.List\u0026lt;CardType\u0026gt;\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetCardsWithout(CardType\ntype)\u003c/em\u003e\u003cbr /\u003e\nGibt Karten ohne bestimmten Typ zur√ºck.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eint\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetCarrots()\u003c/em\u003e\u003cbr /\u003e\nDie Anzahl an Karotten die der Spieler zur Zeit auf der Hand\nhat.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eint\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetFieldIndex()\u003c/em\u003e\u003cbr /\u003e\nDie aktuelle Position der Figur auf dem Spielfeld.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eAction\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetLastNonSkipAction\u003c/em\u003e\u003cbr /\u003e\nGibt letzte Aktion des Spielers zur√ºck.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003esc.shared.PlayerColor\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetPlayerColor()\u003c/em\u003e\u003cbr /\u003e\nDie Farbe dieses Spielers auf dem Spielbrett\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eint\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetSalads()\u003c/em\u003e\u003cbr /\u003e\nDie Anzahl der Salate, die dieser Spieler noch verspeisen muss.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eboolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003einGoal()\u003c/em\u003e\u003cbr /\u003e\n√úberpr√ºft, ob Spieler im Ziel.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eboolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eownsCardOfType(CardType\ntype)\u003c/em\u003e\u003cbr /\u003e\n√úberpr√ºft ob Spieler bestimmte Karte noch besitzt\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\nDie Vollst√§ndige API ist in /doc/sc/plugin2018/Player.html zu finden.\n\nDie Meisten dieser Funktionen sind selbsterkl√§rend. Dennoch sind hier\neinige Beispiele angegeben:\n\n    System.out.print(\"Du hast noch folgende Karten: \");\n    for (CardType c : currentPlayer.getCards()) {\n        System.out.print(c + \" \");\n    }\n    System.out.println();\n\nDies w√ºrde alle Karten ausgeben, welche man noch hat.\n\n    if (currentPlayer.inGoal() \u0026\u0026 !currentPlayer.getCards().isEmpty()) {\n        System.out.println(\"Was fuer eine Verschwendung.\");\n    }\n\nDie If-Bedingung w√ºrde dann ausgef√ºhrt werden, wenn man im Ziel ist,\nallerdings noch Karten hat.\n\nEine weitere wichtige Funktion ist *getFieldIndex*. Diese Funktion wird\nh√§ufig im Dokument ‚ÄûHase\\_Igel\\_Spielbrett‚Äú verwendet.\n\nNeben diesen Funktionen existieren noch einige ‚ÄûSetter‚Äú. Diese sind\nallerdings haupts√§chlich f√ºr den Server notwendig und haben einen\ngeringen praktischen Nutzten f√ºr uns.\n\n## Aufgabe\n\nSchreibe eine If-Bedingung, welche abfragt, ob beide Spieler auf dem\nselben Feld sind. Da dies nur m√∂glich ist, wenn man auf dem Start-\nZielfeld ist, soll zun√§chst abgefragt werden, ob der aktuelle Spieler\nauf dem Start- Zielfeld ist. Tipp: Es gibt die Funktion getTypeAt der\nKlasse Board. Weiter Informationen sind im Dokument\n‚ÄûHase\\_Igel\\_Spielbrett‚Äú zu finden.\n\n# GameRuleLogic: Hilfreiche Hilfsfunktionen\n\nDie Klasse GameRuleLogic hat viele Hilfsfunktionen, mit welchen man die\nRegeln des Spieles √ºberpr√ºfen kann. Hierbei sind alle Funktionen static.\nD.h., dass man sie ohne eine Instanz aufrufen kann.\n\n\u003ctable\u003e\n\u003ccolgroup\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003c/colgroup\u003e\n\u003ctbody\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic int\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003ecalculateCarrots(int\nmoveCount)\u003c/em\u003e\u003cbr /\u003e\nBerechnet wie viele Karotten f√ºr einen Zug der L√§nge moveCount ben√∂tigt\nwerden.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic int\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003ecalculateMoveableFields(int\ncarrots)\u003c/em\u003e\u003cbr /\u003e\nBerechnet, wie weit man mit carrots Karotten gehen kann. Beispiel: Mit\n68 Karotten kann man 11 Felder weit gehen.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003ecanPlayCard(GameState\nstate)*\u003c/em\u003e\u003cbr /\u003e\nGibt zur√ºck, ob der derzeitige Spieler eine Karte spielen kann.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToAdvance(GameState state,\nint distance)\u003c/em\u003e\u003cbr /\u003e\n√úberpr√ºft \u003cem\u003eAdvance\u003c/em\u003e Aktionen auf ihre Korrektheit.\n\u003cem\u003eDistance\u003c/em\u003e steht f√ºr die Distanz die man zur√ºcklegen\nwill.Three\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToEat(GameState\nstate)\u003c/em\u003e\u003cbr /\u003e\n√úberpr√ºft \u003cem\u003eEatSalad\u003c/em\u003e Z√ºge auf Korrektheit. Diese Funktion bezieht\nsich \u003cstrong\u003enicht\u003c/strong\u003e auf die Karte\n\u003cem\u003eTAKE_OR_DROP_CARROTS\u003c/em\u003e\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToExchangeCarrots(GameState\nstate, int n)\u003c/em\u003e\u003cbr /\u003e\n√úberpr√ºft ob der derzeitige Spieler 10 Karotten nehmen oder abgeben\nkann. ‚Äûn‚Äú kann entweder 10 oder -10 sein. Je nachdem ob man annehmen\noder abgeben will. Diese Funktion bezieht sich \u003cstrong\u003enicht\u003c/strong\u003e\nauf die Karte \u003cem\u003eEAT_SALAD\u003c/em\u003e.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToFallBack(GameState\nstate)\u003c/em\u003e\u003cbr /\u003e\n√úberpr√ºft \u003cem\u003eFallBack\u003c/em\u003e Z√ºge auf Korrektheit\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToPlayCard(GameState state,\nCardType c,int n)*\u003c/em\u003e\u003cbr /\u003e\n√úberpr√ºft ob der derzeitige Spieler die Karte spielen kann. ‚Äûn‚Äú wird f√ºr\ndie \u003cem\u003eTAKE_OR_DROP_CARROTS\u003c/em\u003e Karte ben√∂tigt (s.u). ‚Äûn‚Äú kann die\nWert 0, 20 oder -20 annehmen.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToPlayEatSalad(GameState\nstate)*\u003c/em\u003e\u003cbr /\u003e\n√úberpr√ºft ob der derzeitige Spieler die \u003cem\u003eEAT_SALAD\u003c/em\u003e Karte spielen\ndarf.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToPlayFallBack(GameState\nstate)*\u003c/em\u003e\u003cbr /\u003e\n√úberpr√ºft ob der derzeitige Spieler die \u003cem\u003eFALL_BACK\u003c/em\u003e Karte spielen\ndarf.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToPlayHurryAhead(GameState\nstate) *\u003c/em\u003e\u003cbr /\u003e\n√úberpr√ºft ob der derzeitige Spieler die \u003cem\u003eHURRY_AHEAD\u003c/em\u003e Karte\nspielen darf.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd\nstyle=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToPlayTakeOrDropCarrots(GameState\nstate,int n)*\u003c/em\u003e\u003cbr /\u003e\n√úberpr√ºft ob der derzeitige Spieler die \u003cem\u003eTAKE_OR_DROP_CARROTS\u003c/em\u003e\nKarte spielen darf. ‚Äûn‚Äú kann entweder 0, 20 oder -20 sein.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToSkip(GameState\nstate)\u003c/em\u003e\u003cbr /\u003e\n√úberpr√ºft, ob der derzeitige Spieler aussetzen darf.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003emustEatSalad(GameState\nstate)\u003c/em\u003e\u003cbr /\u003e\n√úberpr√ºft ob man einen Salat fressen muss. Dies ist immer der Fall, wenn\nman in der vorherigen Runde ein Salatfeld betreten hat.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003emustPlayCard(GameState state)\n*\u003c/em\u003e\u003cbr /\u003e\n√úberpr√ºft ob eine Karte gespielt werden muss.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eplayerMustAdvance(GameState\nstate)\u003c/em\u003e\u003cbr /\u003e\n√úberpr√ºft ab der derzeitige Spieler im n√§chsten Zug einen Vorw√§rtszug\nmachen muss.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\\*Diese Funktionen werden im Kapitel ‚ÄûErweiterte Beispiele‚Äú besprochen.\n\nDie komplette API-Dokumentation ist in\ndoc/sc/plugin2018/util/GameRuleLogic.html zu finden.\n\n## Simulation des Gegners\n\nNat√ºrlich kann man alle diese Funktionen auch auf den Gegenspieler\nanwenden. Daf√ºr m√ºssen wir allerdings eine Kopie des GameState\nerstellen:\n\n    try {\n      GameState otherGame = gameState.clone(); // Deep-Copy\n      // Rundenanzahl hochsetzten f√ºr switch Befehl:\n      otherGame.setTurn(gameState.getTurn()+1);\n      // Tausche currentPlayer (h√§ngt von der Rundenanzahl ab):\n      otherGame.switchCurrentPlayer();\n      // Gib Informationen √ºber den Gegner aus:\n      System.out.println(\"CurrentPlayer von otherGame:\" + otherGame.getCurrentPlayer());\n    } catch (CloneNotSupportedException e1) { // Fehlerbehandlung\n      e1.printStackTrace();\n    }\n\nAlle Funktionen von GameRuleLogic k√∂nnen wir nun, mithilfe der Variable\notherGame, auf den Gegner anwenden.\n\n## Einf√ºhrende Beispiele\n\nDie meisten Funktionen dieser Klasse sind selbsterkl√§rend. Dennoch\nwerden einige der h√§ufig verwendeten Funktionen mit kleinen Beispielen\nvorgestellt.\n\n    if (GameRuleLogic.isValidToEat(gameState) != GameRuleLogic.mustEatSalad(gameState)) {\n      System.out.println(\"Unm√∂glich\");\n    }\n\nNach den Regeln muss man immer ein Salat essen, wenn man im vorherigen\nZug ein Salatfeld betreten hat. Au√üerdem ist dies die einzige\nM√∂glichkeit die Aktion EatSalad auszuf√ºhren (nicht mit dem Spielen der\nEAT\\_SALAD Karte verwechseln).\n\nDadurch wird auch die Unerf√ºllbarkeit des folgenden Ausdrucks\nimpliziert:\n\n    if (GameRuleLogic.isValidToEat(gameState) \u0026\u0026\n        (GameRuleLogic.isValidToFallBack(gameState) || GameRuleLogic.canMove(gameState))) {\n      System.out.println(\"Unm√∂glich\");\n    }\n\nEine weiter hilfreiche Funktion ist *isValidToAdvance*. Mit dieser\nFunktion wird √ºberpr√ºft, ob ein Vorw√§rtszug mit der √ºbergeben Distanz\n√ºberhaupt m√∂glich ist:\n\n    // berechne die maximale Entfernung, welche man laufen darf\n    int max_move = GameRuleLogic.calculateMoveableFields(currentPlayer.getCarrots());\n\n    if (GameRuleLogic.isValidToAdvance(gameState, max_move +1)) {\n      System.out.println(\"Unm√∂glich\");\n    }\n\nDie Funktion *calculateMoveableFields* gibt hierbei die maximale\nEntfernung zur√ºck, welche man mit den √ºbergebenen Karotten laufen darf.\nDiese maximale Entfernung wird immer um 1 erh√∂ht, was dazu f√ºhrt, dass\nder Zug immer unm√∂glich ist.\n\n## Erweitertes Beispiel\n\nAlle Funktionen die mit einem \\* markiert wurden (s.o) haben eine\nGemeinsamkeit. Sie beziehen sich auf das Spielen von Karten. Das Spielen\nvon Karten ist allerdings nur erlaubt, wenn man das entsprechende\nHasenfeld in der selben Zug betreten hat. Deshalb m√ºssen wir GameState\nbearbeiten, damit diese Funktionen √ºberhaupt Sinn haben. Das folgende\nBeispiel gibt eine M√∂glichkeit an, wie man diese Funktionen einsetzten\nkann:\n\n    int nextHareFieldIndex = gameState.getNextFieldByType(FieldType.HARE,\n                                                          currentPlayer.getFieldIndex())\n    // wenn es ein n√§chstes Hasenfeld gibt\n    if (nextHareFieldIndex \u003e 0) {\n      try {\n\n        GameState gameHare = gameState.clone(); // erstelle Deep-Copy\n        Player harePlayer = gameHare.getCurrentPlayer(); // erstelle Shallow-Copy\n\n        //setzte den aktuellen Spieler auf ein Hasenfeld\n        harePlayer.setFieldIndex(nextHareFieldIndex);\n        System.out.println(gameHare.getCurrentPlayer().getCards()); // gib alle Karten aus\n\n        // Welche Karten kann man spielen?\n        System.out.println(\"Play EatSalad: \" +\n                           GameRuleLogic.isValidToPlayEatSalad(gameHare));\n        System.out.println(\"Play TakeOrDropCarrots: \" +\n                           GameRuleLogic.isValidToPlayTakeOrDropCarrots(gameHare,20));\n        System.out.println(\"Play HurryAhead: \" +\n                           GameRuleLogic.isValidToPlayHurryAhead(gameHare));\n        System.out.println(\"Play FallBack: \" +\n                           GameRuleLogic.isValidToPlayFallBack(gameHare));\n\n      } catch (CloneNotSupportedException e1) {\n        e1.printStackTrace();\n      }\n    }\n\nHierf√ºr m√ºssen wir den Spieler einfach nur auf das Hasenfeld setzten.\nAllerdings wird nicht √ºberpr√ºft, ob der Spieler √ºberhaupt bis zum\nn√§chsten Hasenfeld laufen kann.\n\n## Aufgaben\n\n1.  Ist das Ausf√ºhren der inneren If-Bedingung wirklich unm√∂glich.\n    Erkl√§re warum oder gib ein Gegenbeispiel an:\n\n\u003c!-- --\u003e\n\n    int dif = gameState.getOtherPlayer().getFieldIndex() - currentPlayer.getFieldIndex();\n\n    if (dif \u003e= 0 \u0026\u0026\n        dif \u003c= GameRuleLogic.calculateMoveableFields(currentPlayer.getCarrots())) {\n      if (GameRuleLogic.isValidToAdvance(gameState, dif)) {\n        System.out.println(\"Unm√∂glich\");\n      }\n    }\n\n1.  Erweiterte das Beispiel aus dem Kapitel ‚ÄûErweitertes Beispiel‚Äú so,\n    dass sicher gestellt wird, dass der aktuelle Spieler auf ein\n    Hasenfeld gesetzt wird, welches er wirklich erreichen kann.\n\n[1] Technisch gesehen hat die Klasse eine private Liste von Feldern.\nAllerdings √§hnelt ein Aufruf der Funktion getTypeAt sehr den Aufruf\neines Arrays. Auch wenn der R√ºckgabewert kein Feld sonder ein FieldType\nist.\n","data":{},"navigation":{"next":{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/einleitung-xml.md","href":"/spiele/hase-und-igel/xml-dokumentation/einleitung-xml"},"current":{"name":"tutorial","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/tutorial.md","href":"/spiele/hase-und-igel/tutorial/tutorial"},"previous":{"name":"start","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/start.md","href":"/spiele/hase-und-igel/tutorial/start"},"sections":[{"name":"Die Software-Challenge","index":0,"expanded":true,"isEmpty":false,"pages":[{"name":"Wettkampfmodalit√§ten","index":2,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/allgemein/wettkampf.md","href":"/allgemein/wettkampf"},{"name":"Das Spiel kennenlernen","index":3,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/allgemein/spiel.md","href":"/allgemein/spiel"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/allgemein/index.md","href":"/allgemein"},{"name":"Spiele","index":1,"virtual":true,"isEmpty":true,"pages":[],"sections":[{"name":"Blokus","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"content","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/content.md","href":"/spiele/blokus/spielregeln/content"},{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/regeln.md","href":"/spiele/blokus/spielregeln/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/index.md","href":"/spiele/blokus/spielregeln"},{"name":"XML-Dokumentation","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/einleitung-xml.md","href":"/spiele/blokus/xml-dokumentation/einleitung-xml"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spiel-betreten.md","href":"/spiele/blokus/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spiel-verlassen.md","href":"/spiele/blokus/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielergebnis.md","href":"/spiele/blokus/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielstatus.md","href":"/spiele/blokus/xml-dokumentation/spielstatus"},{"name":"spielsteine","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielsteine.md","href":"/spiele/blokus/xml-dokumentation/spielsteine"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielverlauf.md","href":"/spiele/blokus/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/xml-dokumentation.md","href":"/spiele/blokus/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/zuege-senden.md","href":"/spiele/blokus/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/zug-anforderung.md","href":"/spiele/blokus/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/index.md","href":"/spiele/blokus/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/index.md","href":"/spiele/blokus"},{"name":"Hase und Igel","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"beispiel","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/beispiel.md","href":"/spiele/hase-und-igel/spielregeln/beispiel"},{"name":"felder","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/felder.md","href":"/spiele/hase-und-igel/spielregeln/felder"},{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/regeln.md","href":"/spiele/hase-und-igel/spielregeln/regeln"},{"name":"spielbeginn","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/spielbeginn.md","href":"/spiele/hase-und-igel/spielregeln/spielbeginn"},{"name":"spielende","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/spielende.md","href":"/spiele/hase-und-igel/spielregeln/spielende"},{"name":"zuege","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/zuege.md","href":"/spiele/hase-und-igel/spielregeln/zuege"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/index.md","href":"/spiele/hase-und-igel/spielregeln"},{"name":"Tutorial","hide":true,"isEmpty":true,"pages":[{"name":"board","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/board.md","href":"/spiele/hase-und-igel/tutorial/board"},{"name":"game-rule-logic","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/game-rule-logic.md","href":"/spiele/hase-und-igel/tutorial/game-rule-logic"},{"name":"player","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/player.md","href":"/spiele/hase-und-igel/tutorial/player"},{"name":"start","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/start.md","href":"/spiele/hase-und-igel/tutorial/start"},{"name":"tutorial","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/tutorial.md","href":"/spiele/hase-und-igel/tutorial/tutorial"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/index.md","href":"/spiele/hase-und-igel/tutorial"},{"name":"XML-Dokumentation","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/einleitung-xml.md","href":"/spiele/hase-und-igel/xml-dokumentation/einleitung-xml"},{"name":"fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/fehler.md","href":"/spiele/hase-und-igel/xml-dokumentation/fehler"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spiel-betreten.md","href":"/spiele/hase-und-igel/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spiel-verlassen.md","href":"/spiele/hase-und-igel/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielergebnis.md","href":"/spiele/hase-und-igel/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielstatus.md","href":"/spiele/hase-und-igel/xml-dokumentation/spielstatus"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielverlauf.md","href":"/spiele/hase-und-igel/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/xml-dokumentation.md","href":"/spiele/hase-und-igel/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/zuege-senden.md","href":"/spiele/hase-und-igel/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/zug-anforderung.md","href":"/spiele/hase-und-igel/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/index.md","href":"/spiele/hase-und-igel/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/index.md","href":"/spiele/hase-und-igel"},{"name":"Hey, Danke f√ºr den Fisch!","hide":true,"expanded":true,"isEmpty":false,"pages":[{"name":"Spielregeln","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/regeln.md","href":"/spiele/penguins/regeln"},{"name":"XML-Schnittstelle","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/xml.md","href":"/spiele/penguins/xml"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/index.md","href":"/spiele/penguins"},{"name":"Hive","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/spielregeln/regeln.md","href":"/spiele/hive/spielregeln/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/spielregeln/index.md","href":"/spiele/hive/spielregeln"},{"name":"XML-Dokumention","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/einleitung-xml.md","href":"/spiele/hive/xml-dokumentation/einleitung-xml"},{"name":"fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/fehler.md","href":"/spiele/hive/xml-dokumentation/fehler"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spiel-betreten.md","href":"/spiele/hive/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spiel-verlassen.md","href":"/spiele/hive/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielergebnis.md","href":"/spiele/hive/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielstatus.md","href":"/spiele/hive/xml-dokumentation/spielstatus"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielverlauf.md","href":"/spiele/hive/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/xml-dokumentation.md","href":"/spiele/hive/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/zuege-senden.md","href":"/spiele/hive/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/zug-anforderung.md","href":"/spiele/hive/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/index.md","href":"/spiele/hive/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/index.md","href":"/spiele/hive"},{"name":"Mississippi Queen","expanded":true,"isEmpty":false,"pages":[{"name":"Spielregeln","index":2,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/mississippi-queen/regeln.md","href":"/spiele/mississippi-queen/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/mississippi-queen/index.md","href":"/spiele/mississippi-queen"},{"name":"Ostseeschach","hide":true,"isEmpty":false,"pages":[{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/regeln.md","href":"/spiele/ostseeschach/regeln"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/xml-dokumentation.md","href":"/spiele/ostseeschach/xml-dokumentation"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/index.md","href":"/spiele/ostseeschach"},{"name":"Piranhas","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/spielregeln/regeln.md","href":"/spiele/piranhas/spielregeln/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/spielregeln/index.md","href":"/spiele/piranhas/spielregeln"},{"name":"XML-Dokumentation","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/einleitung-xml.md","href":"/spiele/piranhas/xml-dokumentation/einleitung-xml"},{"name":"fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/fehler.md","href":"/spiele/piranhas/xml-dokumentation/fehler"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spiel-betreten.md","href":"/spiele/piranhas/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spiel-verlassen.md","href":"/spiele/piranhas/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielergebnis.md","href":"/spiele/piranhas/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielstatus.md","href":"/spiele/piranhas/xml-dokumentation/spielstatus"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielverlauf.md","href":"/spiele/piranhas/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/xml-dokumentation.md","href":"/spiele/piranhas/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/zuege-senden.md","href":"/spiele/piranhas/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/zug-anforderung.md","href":"/spiele/piranhas/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/index.md","href":"/spiele/piranhas/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/index.md","href":"/spiele/piranhas"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/index.md","href":"/spiele"},{"name":"Entwicklung","index":2,"isEmpty":false,"pages":[{"name":"Objektorientierte Programmierung","index":3,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/einfuehrung-oop.md","href":"/entwicklung/einfuehrung-oop"},{"name":"Sauberer Programmierstil","index":4,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/sauberer-programmierstil.md","href":"/entwicklung/sauberer-programmierstil"},{"name":"Installation von Java","index":5,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/installation-von-java.md","href":"/entwicklung/installation-von-java"},{"name":"Einrichtung der Entwicklungsumgebung","index":6,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/einrichtung-der-entwicklungsumgebung.md","href":"/entwicklung/einrichtung-der-entwicklungsumgebung"},{"name":"Bedienung von Eclipse","index":7,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/bedienung-von-eclipse.md","href":"/entwicklung/bedienung-von-eclipse"},{"name":"Spielervorlage erweitern","index":7,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/simpleclient-erweitern.md","href":"/entwicklung/simpleclient-erweitern"},{"name":"Idee implementieren","index":8,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/eine-idee-implementieren.md","href":"/entwicklung/eine-idee-implementieren"},{"name":"Computerspieler abgabefertig machen","index":9,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/abgabe.md","href":"/entwicklung/abgabe"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/index.md","href":"/entwicklung"}],"pages":[{"name":"Start","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/index.md","href":"/"},{"name":"Technische Grundlagen","index":2,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/glossar.md","href":"/glossar"},{"name":"Lesezeichen","index":3,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/bookmark.md","href":"/bookmark"},{"name":"F.A.Q.","index":4,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/faq.md","href":"/faq"}]}},"__N_SSG":true},"page":"/[[...page]]","query":{"page":["spiele","hase-und-igel","tutorial","tutorial"]},"buildId":"gJRxG6W-71yU5ToWtMTf6","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>